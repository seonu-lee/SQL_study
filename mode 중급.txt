--1. SQL Aggregate Functions (집계함수)
/*COUNT: 특정 열에 몇 개의 행이 있는지 계산합니다.
SUM:특정 열의 모든 값을 더합니다.
MIN, MAX: 각각 특정 열의 가장 낮은 값과 가장 높은 값을 반환합니다.
AVG: 선택된 값 그룹의 평균을 계산합니다. 
산술 연산자는 행에 대해서만 연산을 수행함->집계 함수는 전체 열에 대해 연산을 수행함 */
--SELECT * FROM tutorial.aapl_historical_stock_price 사용

--2. SQL COUNT
--모든 행 계산
SELECT COUNT(*)
  FROM tutorial.aapl_historical_stock_price --COUNT(1)과 같은 결과를 냄, null이 포함
--개별 열 계산
SELECT COUNT(high)
  FROM tutorial.aapl_historical_stock_price --high열이 null이 아닌 모든 행의 개수를 계산
--연습문제:Write a query to count the number of non-null rows in the low column.
SELECT COUNT(low) 
  FROM tutorial.aapl_historical_stock_price
--숫자가 아닌 열 계산
SELECT COUNT(date) AS count_of_date --보기편하게 열 이름을 지정하는 것이 좋음
  FROM tutorial.aapl_historical_stock_price
--공백을 사용해야 하는 경우에는 유일하게 큰따옴표를 사용, 그 외의 경우에는 작은따옴표를 사용
SELECT COUNT(year) AS year,
       COUNT(month) AS month,
       COUNT(open) AS open,
       COUNT(high) AS high,
       COUNT(low) AS low,
       COUNT(close) AS close,
       COUNT(volume) AS volume
  FROM tutorial.aapl_historical_stock_price

--3. SQL SUM
--SQL SUM 함수: 주어진 열의 값을 합산하는 SQL 집계 함수, count와 달리 숫자값이 포함된 열에만 사용가능
SELECT SUM(volume)
  FROM tutorial.aapl_historical_stock_price
--집계함수는 수직으로만 계산됨, 행에 걸쳐 계산하려면 간단한 산술연산을 사용해야함(high+low)
--SUM은 null 을 0으로 처리함
--연습문제:Write a query to calculate the average opening price (hint: you will need to use both COUNT and SUM, as well as some simple arithmetic.).
SELECT SUM(open)/count(open) AS avg_open
  FROM tutorial.aapl_historical_stock_price

--4. SQL MIN/MAX
--SQL MIN 및 MAX 함수:특정 열의 가장 낮은 값과 가장 높은 값을 반환하는 SQL 집계 함수
--숫자가 아닌 열에도 사용할 수 있다는 점에서 count와 유사
--MIN "A"에 알파벳순으로 가장 가까운 가장 낮은 숫자, 가장 빠른 날짜 또는 숫자가 아닌 값을 반환
SELECT MIN(volume) AS min_volume,
       MAX(volume) AS max_volume
  FROM tutorial.aapl_historical_stock_price
--연습문제:What was Apple's lowest stock price (at the time of this data collection)?, 그당시 최저가
SELECT MIN(low)
  FROM tutorial.aapl_historical_stock_price
--연습문제:What was the highest single-day increase in Apple's share value? 하루동안 가장 큰 상승
SELECT MAX(close - open)
  FROM tutorial.aapl_historical_stock_price

--5. SQL AVG
--SQL AVG 함수: 선택한 값 그룹의 평균을 계산하는 SQL 집계 함수, 숫자 열에만 사용가능, Null 값을 완전히 무시
SELECT AVG(high)
  FROM tutorial.aapl_historical_stock_price
 WHERE high IS NOT NULL
SELECT AVG(high)
  FROM tutorial.aapl_historical_stock_price
-- 위에 두 쿼리의 결과가 같음(avg는 null을 무시하기 때문)
--연습문제:Write a query that calculates the average daily trade volume for Apple stock.
SELECT AVG(volume) AS avg_volume
  FROM tutorial.aapl_historical_stock_price

--6. SQL GROUP BY
--SQL GROUP BY 절: 테이블의 일부만 집계하고 싶을 때 사용
SELECT year,
       COUNT(*) AS count
  FROM tutorial.aapl_historical_stock_price
 GROUP BY year
여러 열로 그룹화할 수 있지만, ORDER BY와 마찬가지로 열 이름은 쉼표로 구분
--연습문제: Calculate the total number of shares traded each month. Order your results chronologically.
SELECT year,
       month,
       SUM(volume) AS volume_sum
  FROM tutorial.aapl_historical_stock_price
 GROUP BY year, month
 ORDER BY year, month
--열 번호로 그룹화
--ORDER BY와 마찬가지로 열 이름을 숫자로 대체 가능(텍스트가 지나치게 길어지는 경우에만 사용하기)
SELECT year,
       month,
       COUNT(*) AS count
  FROM tutorial.aapl_historical_stock_price
 GROUP BY 1, 2
--ORDER BY와 함께 GROUP BY 사용
--GROUP BY에서 열 이름의 순서는 중요하지 않음, 결과 동일함
--ORDER BY는 열 이름의 순서에 따라 정렬됨
SELECT year,
       month,
       COUNT(*) AS count
  FROM tutorial.aapl_historical_stock_price
 GROUP BY year, month
 ORDER BY month, year
--LIMIT과 함께 GROUP BY 사용
--SQL은 LIMIT절 전에 집계를 평가함 
--연습문제: Write a query to calculate the average daily price change in Apple stock, grouped by year.
SELECT year,
       AVG(close - open) AS avg_daily_change
  FROM tutorial.aapl_historical_stock_price
 GROUP BY 1
 ORDER BY 1
--연습문제: Write a query that calculates the lowest and highest prices that Apple stock achieved each month.
SELECT year,
       month,
       MIN(low) AS lowest_price,
       MAX(high) AS highest_price
  FROM tutorial.aapl_historical_stock_price
 GROUP BY 1, 2
 ORDER BY 1, 2

--7. SQL HAVING
--SQL HAVING 절: 집계 열을 필터링 함
SELECT year,
       month,
       MAX(high) AS month_high
  FROM tutorial.aapl_historical_stock_price
 GROUP BY year, month
HAVING MAX(high) > 400
 ORDER BY year, month
--쿼리 절 순서
/*SELECT
FROM
WHERE
GROUP BY
HAVING
ORDER BY
(LIMIT)*/

--8. SQL CASE
SELECT * FROM benn.college_football_players --사용
--SQL CASE 문: SQL에서 if/then 논리를 처리하는 방식
--CASE문장 뒤에는 적어도 한 쌍의 WHEN and THEN문이 옴
--모든 CASE명령문은 END명령문으로 끝나야함
SELECT player_name,
       year,
       CASE WHEN year = 'SR' THEN 'yes'
            ELSE NULL END AS is_a_senior
  FROM benn.college_football_players
--year가 SR이면 yes, 아니면 null
SELECT player_name,
       year,
       CASE WHEN year = 'SR' THEN 'yes'
            ELSE 'no' END AS is_a_senior
  FROM benn.college_football_players
--연습문제: Write a query that includes a column that is flagged "yes" when a player is from California, and sort the results with those players first. 
SELECT player_name,
       state,
       CASE WHEN state = 'CA' THEN 'yes'
            ELSE NULL END AS from_california
  FROM benn.college_football_players
 ORDER BY 3
--정렬할때 null값이 맨 마지막
--CASE 문에 여러 조건 추가
SELECT player_name,
       weight,
       CASE WHEN weight > 250 THEN 'over 250'
            WHEN weight > 200 THEN '201-250'
            WHEN weight > 175 THEN '176-200'
            ELSE '175 or under' END AS weight_group
  FROM benn.college_football_players
-- 효과적이긴 하지만 겹치지 않는 명령문을 만드는 것이 좋음
SELECT player_name,
       weight,
       CASE WHEN weight > 250 THEN 'over 250'
            WHEN weight > 200 AND weight <= 250 THEN '201-250'
            WHEN weight > 175 AND weight <= 200 THEN '176-200'
            ELSE '175 or under' END AS weight_group
  FROM benn.college_football_players
--연습문제: Write a query that includes players' names and a column that classifies them into four categories based on height. Keep in mind that the answer we provide is only one of many possible answers, since you could divide players' heights in many ways.
SELECT player_name,
       height,
       CASE WHEN height > 74 THEN 'over 74'
            WHEN height > 72 AND height <= 74 THEN '73-74'
            WHEN height > 70 AND height <= 72 THEN '71-72'
            ELSE 'under 70' END AS height_group
  FROM benn.college_football_players
--CASE 기본 사항에 대한 간략한 검토:
/* 1. 문장 CASE은 항상 SELECT절 에 들어갑니다.
2. CASE다음 구성 요소를 포함해야 합니다: WHEN, THEN, 및 END. ELSE는 선택적 구성 요소입니다.
3. WHEN와 THEN 사이에 있는 조건 연산자(예: WHERE) 를 사용하여 모든 조건문을 만들 수 있습니다. 여기에는 AND와OR를 사용하여 여러 조건문을 연결하는 것도 포함됩니다 .
4. 여러 개의 WHEN진술문을 포함할 수 있으며, 해결되지 않은 상황을 처리하기 위한 ELSE 진술문도 포함할 수 있습니다. */
--연습문제: Write a query that selects all columns from benn.college_football_players and adds an additional column that displays the player's name if that player is a junior or senior.
SELECT *,
       CASE WHEN year IN ('JR', 'SR') THEN player_name ELSE NULL END AS upperclass_player_name
  FROM benn.college_football_players
--집계 함수와 함께 CASE 사용
SELECT CASE WHEN year = 'FR' THEN 'FR'
            ELSE 'Not FR' END AS year_group,
            COUNT(1) AS count
  FROM benn.college_football_players
 GROUP BY CASE WHEN year = 'FR' THEN 'FR'
               ELSE 'Not FR' END
SELECT COUNT(1) AS fr_count
  FROM benn.college_football_players
 WHERE year = 'FR'
--WHERE절을 사용하면 조건을 하나만 계산할 수 있습니다. 다음은 하나의 쿼리에서 여러 조건을 계산하는 예입니다.
SELECT CASE WHEN year = 'FR' THEN 'FR'
            WHEN year = 'SO' THEN 'SO'
            WHEN year = 'JR' THEN 'JR'
            WHEN year = 'SR' THEN 'SR'
            ELSE 'No Year Data' END AS year_group,
            COUNT(1) AS count
  FROM benn.college_football_players
 GROUP BY 1
--숫자대신 열의 별칭도 사용가능
SELECT CASE WHEN year = 'FR' THEN 'FR'
            WHEN year = 'SO' THEN 'SO'
            WHEN year = 'JR' THEN 'JR'
            WHEN year = 'SR' THEN 'SR'
            ELSE 'No Year Data' END AS year_group,
            COUNT(1) AS count
  FROM benn.college_football_players
 GROUP BY year_group
--문장 전체를 반복하기로 선택한 경우 절 에 복사/붙여넣기할 때 열 이름을 제거
SELECT CASE WHEN year = 'FR' THEN 'FR'
            WHEN year = 'SO' THEN 'SO'
            WHEN year = 'JR' THEN 'JR'
            WHEN year = 'SR' THEN 'SR'
            ELSE 'No Year Data' END AS year_group,
            COUNT(1) AS count
  FROM benn.college_football_players
 GROUP BY CASE WHEN year = 'FR' THEN 'FR'
               WHEN year = 'SO' THEN 'SO'
               WHEN year = 'JR' THEN 'JR'
               WHEN year = 'SR' THEN 'SR'
               ELSE 'No Year Data' END
--연습문제: Write a query that counts the number of 300lb+ players for each of the following regions: West Coast (CA, OR, WA), Texas, and Other (everywhere else).
SELECT CASE WHEN state IN ('CA', 'OR', 'WA') THEN 'West Coast'
            WHEN state = 'TX' THEN 'Texas'
            ELSE 'Other' END AS arbitrary_regional_designation,
            COUNT(1) AS players
  FROM benn.college_football_players
 WHERE weight >= 300
 GROUP BY 1
--연습문제: Write a query that calculates the combined weight of all underclass players (FR/SO) in California as well as the combined weight of all upperclass players (JR/SR) in California.
SELECT CASE WHEN year IN ('FR', 'SO') THEN 'underclass'
            WHEN year IN ('JR', 'SR') THEN 'upperclass'
            ELSE NULL END AS class_group,
       SUM(weight) AS combined_player_weight
  FROM benn.college_football_players
 WHERE state = 'CA'
 GROUP BY 1
--집계 함수 내부에서 CASE 사용
--pivoting: 데이터를 가로로 표시하기 위해 세로->가로, 수평으로 바꿈
SELECT COUNT(CASE WHEN year = 'FR' THEN 1 ELSE NULL END) AS fr_count,
       COUNT(CASE WHEN year = 'SO' THEN 1 ELSE NULL END) AS so_count,
       COUNT(CASE WHEN year = 'JR' THEN 1 ELSE NULL END) AS jr_count,
       COUNT(CASE WHEN year = 'SR' THEN 1 ELSE NULL END) AS sr_count
  FROM benn.college_football_players
--연습문제: Write a query that displays the number of players in each state, with FR, SO, JR, and SR players in separate columns and another column for the total number of players. Order results such that states with the most players come first.
SELECT state,
       COUNT(CASE WHEN year = 'FR' THEN 1 ELSE NULL END) AS fr_count,
       COUNT(CASE WHEN year = 'SO' THEN 1 ELSE NULL END) AS so_count,
       COUNT(CASE WHEN year = 'JR' THEN 1 ELSE NULL END) AS jr_count,
       COUNT(CASE WHEN year = 'SR' THEN 1 ELSE NULL END) AS sr_count,
       COUNT(1) AS total_players
  FROM benn.college_football_players
 GROUP BY state
 ORDER BY total_players DESC
--연습문제:Write a query that shows the number of players at schools with names that start with A through M, and the number at schools with names starting with N - Z.
SELECT CASE WHEN school_name < 'n' THEN 'A-M'
            WHEN school_name >= 'n' THEN 'N-Z'
            ELSE NULL END AS school_name_group,
       COUNT(1) AS players
  FROM benn.college_football_players
 GROUP BY 1

-- 9. SQL DISTINCT
/* 1. SQL DISTINCT: 특정 열의 고유 값만 보고 싶을 때
2. 각 열의 고유 값을 살펴보면 데이터를 그룹화하거나 필터링하는 방법을 파악하는 데 도움됨
3.두 개 이상의 열을 포함하는 경우 해당 두 열의 모든 고유한 쌍이 포함됨
4. select절 시작 뿐만 아니라 집계함수 안에서도 사용됨*/

SELECT DISTINCT month
  FROM tutorial.aapl_historical_stock_price

--두 개 이상의 열을 포함하는 경우 해당 두 열의 모든 고유한 쌍이 포함됨
SELECT DISTINCT year, month
  FROM tutorial.aapl_historical_stock_price

--연습문제: Write a query that returns the unique values in the year column, in chronological order.
SELECT DISTINCT year
  FROM tutorial.aapl_historical_stock_price
 ORDER BY year

--집계에서 DISTINCT 사용: 함수와 함께 가장 많이 사용됨(count에서 많이 씀/ 하지만 sum,avg는 실용적이지 않음/ max,min은 있으나 없으나 똑같음)-> 쿼리속도가 느려짐 ㅜㅜ
SELECT COUNT(DISTINCT month) AS unique_months
  FROM tutorial.aapl_historical_stock_price

--연습문제: Write a query that counts the number of unique values in the month column for each year.
SELECT year,
       COUNT(DISTINCT month) AS months_count
  FROM tutorial.aapl_historical_stock_price
 GROUP BY year
 ORDER BY year

--연습문제: Write a query that separately counts the number of unique values in the month column and the number of unique values in the `year` column.
SELECT COUNT(DISTINCT year) AS years_count,
       COUNT(DISTINCT month) AS months_count
  FROM tutorial.aapl_historical_stock_price

--10. SQL Joins
/* 1. SQL 조인 소개: 관계형 개념:  "관계형 데이터베이스"라는 용어는 그 안의 테이블들이 서로 "관련"되어 있다는 사실을 의미->여러 테이블의 정보를 쉽게 결합할 수 있도록 하는 공통 식별자를 포함하고 있다는 것
2. SQL의 별칭: 조인을 수행할 때 테이블 이름에 별칭을 지정하는 것이 쉬움, 열 이름과 마찬가지로 모두 소문자, 공백 대신 언더바 사용하기
3. JOIN 및 ON: ON은 두 테이블이 서로 어떻게 관련되어있는지를 나타냄, 두 테이블을 연결하는 관계를 "매핑"이라고 함. 서로 매핑되는 두 열을 "외래키", "조인키" 라고 함. */ 

SELECT teams.conference AS conference,
       AVG(players.weight) AS average_weight
  FROM benn.college_football_players players
  JOIN benn.college_football_teams teams
    ON teams.school_name = players.school_name
 GROUP BY teams.conference
 ORDER BY AVG(players.weight) DESC

-연습문제: Write a query that selects the school name, player name, position, and weight for every player in Georgia, ordered by weight (heaviest to lightest). Be sure to make an alias for the table, and to reference all column names in relation to the alias.
SELECT players.school_name,
       players.player_name,
       players.position,
       players.weight
  FROM benn.college_football_players players
 WHERE players.state = 'GA'
 ORDER BY players.weight DESC

SELECT *
  FROM benn.college_football_players players
  JOIN benn.college_football_teams teams
    ON teams.school_name = players.school_name

--SELECT *는 뒤에 있는 테이블뿐만 아니라 두 테이블의 모든 열을 반환함 / 한 테이블의 열만 반환하려면 SELECT players.*

--11. SQL INNER JOIN
/* 1. INNER JOIN: 두 테이블에서 해당 명령문에 명시된 조인 조건을 충족하지 않는 행을 제거함, 수학적으로 내부 조인은 두 테이블의 교집합, join과 일치, 두 테이블 모두에서 일치하는 값만 보여줌
2. 동일한 열 이름을 가진 테이블 조인: 결과는 지정된 이름을 가진 하나의 열만 출력됨, 두 열 모두 출력도 가능하지만 동일한 데이터를 가짐*/

--연습문제: Write a query that displays player names, school names and conferences for schools in the "FBS (Division I-A Teams)" division.
SELECT players.player_name,
       players.school_name,
       teams.conference
  FROM benn.college_football_players players
  JOIN benn.college_football_teams teams
    ON teams.school_name = players.school_name
 WHERE teams.division = 'FBS (Division I-A Teams)'


--12. SQL OUTER JOIN
/* 1. LEFT JOIN(OUTER LEFT JOIN): 왼쪽 테이블에서 일치하지 않는 행만 반환하고 , 두 테이블에서 일치하는 행도 반환합니다.
RIGHT JOIN(OUTER RIGHT JOIN): 오른쪽 테이블에서 일치하지 않는 행만 반환하고 , 두 테이블에서 일치하는 행도 반환합니다.
FULL OUTER JOIN(OUTER JOIN): 두 테이블 모두에서 일치하지 않는 행 과 두 테이블 모두에서 일치하는 행을 반환합니다, 두 테이블의 합집합(union)*/

--13. SQL LEFT JOIN

SELECT companies.permalink AS companies_permalink,
       companies.name AS companies_name,
       acquisitions.company_permalink AS acquisitions_permalink,
       acquisitions.acquired_at AS acquired_date
  FROM tutorial.crunchbase_companies companies
  JOIN tutorial.crunchbase_acquisitions acquisitions
    ON companies.permalink = acquisitions.company_permalink
--companies 테이블과 동일한 매핑값이 acquisitions 테이블에 2개있으면 두 번 매핑되어 두 행으로 나타남 

SELECT companies.permalink AS companies_permalink,
       companies.name AS companies_name,
       acquisitions.company_permalink AS acquisitions_permalink,
       acquisitions.acquired_at AS acquired_date
  FROM tutorial.crunchbase_companies companies
  LEFT JOIN tutorial.crunchbase_acquisitions acquisitions
    ON companies.permalink = acquisitions.company_permalink
-- 테이블에 일치하는 항목이 있는지 여부에 관계없이 LEFT JOIN테이블에 있는 모든 행을 반환하게 함

--연습문제: Write a query that performs an inner join between the tutorial.crunchbase_acquisitions table and the tutorial.crunchbase_companies table, but instead of listing individual rows, count the number of non-null rows in each table.
SELECT COUNT(companies.permalink) AS companies_rowcount, --1673
       COUNT(acquisitions.company_permalink) AS acquisitions_rowcount --1673
  FROM tutorial.crunchbase_companies companies
  JOIN tutorial.crunchbase_acquisitions acquisitions
    ON companies.permalink = acquisitions.company_permalink
--inner join은 두 테이블 모두 null값을 포함하고 있지 않아 행의 수가 같음

--연습문제: Modify the query above to be a LEFT JOIN. Note the difference in results.
SELECT COUNT(companies.permalink) AS companies_rowcount, --27355
       COUNT(acquisitions.company_permalink) AS acquisitions_rowcount --1673
  FROM tutorial.crunchbase_companies companies
  LEFT JOIN tutorial.crunchbase_acquisitions acquisitions
    ON companies.permalink = acquisitions.company_permalink
-- count()는 null을 제외하고 셈,  LEFT JOIN테이블은 null값이 존재하지 않고, null값을 가진 acquisitions 테이블의 행의 수가 더 적음

--연습문제: Count the number of unique companies (don't double-count companies) and unique acquired companies by state. Do not include results for which there is no state data, and order by the number of acquired companies from highest to lowest.
SELECT companies.state_code,
       COUNT(DISTINCT companies.permalink) AS unique_companies,
       COUNT(DISTINCT acquisitions.company_permalink) AS unique_companies_acquired
  FROM tutorial.crunchbase_companies companies
  LEFT JOIN tutorial.crunchbase_acquisitions acquisitions
    ON companies.permalink = acquisitions.company_permalink
 WHERE companies.state_code IS NOT NULL
 GROUP BY 1
 ORDER BY 3 DESC

-- 14. SQL RIGHT JOIN
/* left join에서 두 테이블의 이름을 바꾸면 right join과 같음 */ 

--연습문제: Rewrite the previous practice query in which you counted total and acquired companies by state, but with a RIGHT JOIN instead of a LEFT JOIN. The goal is to produce the exact same results.
SELECT companies.state_code,
       COUNT(DISTINCT companies.permalink) AS unique_companies,
       COUNT(DISTINCT acquisitions.company_permalink) AS acquired_companies
  FROM tutorial.crunchbase_acquisitions acquisitions
 RIGHT JOIN tutorial.crunchbase_companies companies
    ON companies.permalink = acquisitions.company_permalink
 WHERE companies.state_code IS NOT NULL
 GROUP BY 1
 ORDER BY 3 DESC

-- 15. SQL Joins Using WHERE or ON
/* 일반적으로는 두 테이블이 이미 조인된 후에 WHERE절에서 필터링 됨.
1. ON 절에서 필터링: 하지만 조인 전에 필터링 해야될 수도 있음 
2. WHERE 절에서 필터링: 조인된 후에 필터링 됨 */ 

SELECT companies.permalink AS companies_permalink,
       companies.name AS companies_name,
       acquisitions.company_permalink AS acquisitions_permalink,
       acquisitions.acquired_at AS acquired_date
  FROM tutorial.crunchbase_companies companies
  LEFT JOIN tutorial.crunchbase_acquisitions acquisitions
    ON companies.permalink = acquisitions.company_permalink
   AND acquisitions.company_permalink != '/company/1000memories'
 ORDER BY 1
-- 조인 발생 전에 조건문 AND가 평가됨, 이는 테이블 중 해당 테이블 하나에만 적용됨, 다른 테이블에서는 여전히 표시될 수 있음

SELECT companies.permalink AS companies_permalink,
       companies.name AS companies_name,
       acquisitions.company_permalink AS acquisitions_permalink,
       acquisitions.acquired_at AS acquired_date
  FROM tutorial.crunchbase_companies companies
  LEFT JOIN tutorial.crunchbase_acquisitions acquisitions
    ON companies.permalink = acquisitions.company_permalink
 WHERE acquisitions.company_permalink != '/company/1000memories'
    OR acquisitions.company_permalink IS NULL --null값도 필터링 될 수 있으므로 null값을 포함하도록 추가함
 ORDER BY 1
-- 조인을 한 뒤에 필터링 했기 때문에 acquisitions에 1000memories이 포함된 행이 아예 반환되지 않음

--연습문제: Write a query that shows a company's name, "status" (found in the Companies table), and the number of unique investors in that company. Order by the number of investors from most to fewest. Limit to only companies in the state of New York.
SELECT companies.name AS company_name, 
       companies.status, 
       COUNT(DISTINCT investments.investor_name) AS unqiue_investors --해당 회사의 고유 투자자 수
  FROM tutorial.crunchbase_companies companies
  LEFT JOIN tutorial.crunchbase_investments investments
    ON companies.permalink = investments.company_permalink
 WHERE companies.state_code = 'NY' --뉴욕주에 있는 회사만
 GROUP BY 1,2
 ORDER BY 3 DESC --투자자 수가 많은 순서대로 정렬

--연습문제: Write a query that lists investors based on the number of companies in which they are invested. Include a row for companies with no investor, and order from most companies to least.
SELECT CASE WHEN investments.investor_name IS NULL THEN 'No Investors' --투자자가 없는 회사 행을 추가
            ELSE investments.investor_name END AS investor,
       COUNT(DISTINCT companies.permalink) AS companies_invested_in
  FROM tutorial.crunchbase_companies companies
  LEFT JOIN tutorial.crunchbase_investments investments
    ON companies.permalink = investments.company_permalink
 GROUP BY 1 --투자자가 투자한 회사 수를 기준
 ORDER BY 2 DESC --투자자가 많은 회사부터 적은 회사 순으로 정렬

-- 16. SQL FULL OUTER JOIN
/* 1. (= FULL JOIN) 일반적으로 집계와 함께 사용되어 두 테이블 간의 겹치는 정도를 파악하는 데 사용됨

SELECT COUNT(CASE WHEN companies.permalink IS NOT NULL AND acquisitions.company_permalink IS NULL
                  THEN companies.permalink ELSE NULL END) AS companies_only,
       COUNT(CASE WHEN companies.permalink IS NOT NULL AND acquisitions.company_permalink IS NOT NULL
                  THEN companies.permalink ELSE NULL END) AS both_tables,
       COUNT(CASE WHEN companies.permalink IS NULL AND acquisitions.company_permalink IS NOT NULL
                  THEN acquisitions.company_permalink ELSE NULL END) AS acquisitions_only
  FROM tutorial.crunchbase_companies companies
  FULL JOIN tutorial.crunchbase_acquisitions acquisitions
    ON companies.permalink = acquisitions.company_permalink

--연습문제: Write a query that joins tutorial.crunchbase_companies and tutorial.crunchbase_investments_part1 using a FULL JOIN. Count up the number of rows that are matched/unmatched as in the example above.
SELECT COUNT(CASE WHEN companies.permalink IS NOT NULL AND investments.company_permalink IS NULL
                      THEN companies.permalink ELSE NULL END) AS companies_only,
           COUNT(CASE WHEN companies.permalink IS NOT NULL AND investments.company_permalink IS NOT NULL
                      THEN companies.permalink ELSE NULL END) AS both_tables,
           COUNT(CASE WHEN companies.permalink IS NULL AND investments.company_permalink IS NOT NULL
                      THEN investments.company_permalink ELSE NULL END) AS investments_only
      FROM tutorial.crunchbase_companies companies
      FULL JOIN tutorial.crunchbase_investments_part1 investments
        ON companies.permalink = investments.company_permalink





